# Instructions

- [ ] AAA — ASCII Adjust After Addition
- [ ] AAD — ASCII Adjust AX Before Division
- [ ] AAM — ASCII Adjust AX After Multiply
- [ ] AAS — ASCII Adjust AL After Subtraction
- [ ] ADC — Add with Carry
- [ ] ADCX — Unsigned Integer Addition of Two Operands with Carry Flag
- [x] ADD — Add
- [ ] ADDPD — Add Packed Double-Precision Floating-Point Values
- [ ] ADDPS — Add Packed Single-Precision Floating-Point Values
- [ ] ADDSD — Add Scalar Double-Precision Floating-Point Values
- [ ] ADDSS — Add Scalar Single-Precision Floating-Point Values
- [ ] ADDSUBPD — Packed Double-FP Add/Subtract
- [ ] ADDSUBPS — Packed Single-FP Add/Subtract
- [ ] ADOX — Unsigned Integer Addition of Two Operands with Overflow Flag
- [ ] AESDEC — Perform One Round of an AES Decryption Flow
- [ ] AESDECLAST — Perform Last Round of an AES Decryption Flow
- [ ] AESENC — Perform One Round of an AES Encryption Flow
- [ ] AESENCLAST — Perform Last Round of an AES Encryption Flow
- [ ] AESIMC — Perform the AES InvMixColumn Transformation
- [ ] AESKEYGENASSIST — AES Round Key Generation Assist
- [ ] AND — Logical AND
- [ ] ANDN — Logical AND NOT
- [ ] ANDPD — Bitwise Logical AND of Packed Double Precision Floating-Point Values
- [ ] ANDPS — Bitwise Logical AND of Packed Single Precision Floating-Point Values
- [ ] ANDNPD — Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values
- [ ] ANDNPS — Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values
- [ ] ARPL — Adjust RPL Field of Segment Selector
- [ ] BLENDPD — Blend Packed Double Precision Floating-Point Values
- [ ] BEXTR — Bit Field Extract
- [ ] BLENDPS — Blend Packed Single Precision Floating-Point Values
- [ ] BLENDVPD — Variable Blend Packed Double Precision Floating-Point Values
- [ ] BLENDVPS — Variable Blend Packed Single Precision Floating-Point Values
- [ ] BLSI — Extract Lowest Set Isolated Bit
- [ ] BLSMSK — Get Mask Up to Lowest Set Bit
- [ ] BLSR — Reset Lowest Set Bit
- [ ] BNDCL — Check Lower Bound
- [ ] BNDCU/BNDCN — Check Upper Bound
- [ ] BNDLDX — Load Extended Bounds Using Address Translation
- [ ] BNDMK — Make Bounds
- [ ] BNDMOV — Move Bounds
- [ ] BNDSTX — Store Extended Bounds Using Address Translation
- [ ] BOUND — Check Array Index Against Bounds
- [ ] BSF — Bit Scan Forward
- [ ] BSR — Bit Scan Reverse
- [ ] BSWAP — Byte Swap
- [ ] BT — Bit Test
- [ ] BTC — Bit Test and Complement
- [ ] BTR — Bit Test and Reset
- [ ] BTS — Bit Test and Set
- [ ] BZHI — Zero High Bits Starting with Specified Bit Position
- [ ] CALL — Call Procedure
- [ ] CBW/CWDE/CDQE — Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword
- [ ] CLAC — Clear AC Flag in EFLAGS Register
- [ ] CLC — Clear Carry Flag
- [ ] CLD — Clear Direction Flag
- [ ] CLFLUSH — Flush Cache Line
- [ ] CLFLUSHOPT — Flush Cache Line Optimized
- [ ] CLI — Clear Interrupt Flag
- [ ] CLTS — Clear Task-Switched Flag in CR0
- [ ] CLWB — Cache Line Write Back
- [ ] CMC — Complement Carry Flag
- [ ] CMOVcc — Conditional Move
- [ ] CMP — Compare Two Operands
- [ ] CMPPD — Compare Packed Double-Precision Floating-Point Values
- [ ] CMPPS — Compare Packed Single-Precision Floating-Point Values
- [ ] CMPS/CMPSB/CMPSW/CMPSD/CMPSQ — Compare String Operands
- [ ] CMPSD — Compare Scalar Double-Precision Floating-Point Value
- [ ] CMPSS — Compare Scalar Single-Precision Floating-Point Value
- [ ] CMPXCHG — Compare and Exchange
- [ ] CMPXCHG8B/CMPXCHG16B — Compare and Exchange Bytes
- [ ] COMISD — Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS
- [ ] COMISS — Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS
- [ ] CPUID — CPU Identification
- [ ] CRC32 — Accumulate CRC32 Value
- [ ] CVTDQ2PD — Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values
- [ ] CVTDQ2PS — Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values
- [ ] CVTPD2DQ — Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers
- [ ] CVTPD2PI — Convert Packed Double-Precision FP Values to Packed Dword Integers
- [ ] CVTPD2PS — Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values
- [ ] CVTPI2PD — Convert Packed Dword Integers to Packed Double-Precision FP Values
- [ ] CVTPI2PS — Convert Packed Dword Integers to Packed Single-Precision FP Values
- [ ] CVTPS2DQ — Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values
- [ ] CVTPS2PD — Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values
- [ ] CVTPS2PI — Convert Packed Single-Precision FP Values to Packed Dword Integers
- [ ] CVTSD2SI — Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer
- [ ] CVTSD2SS — Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value
- [ ] CVTSI2SD — Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value
- [ ] CVTSI2SS — Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value
- [ ] CVTSS2SD — Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value
- [ ] CVTSS2SI — Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer
- [ ] CVTTPD2DQ — Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers
- [ ] CVTTPD2PI — Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers
- [ ] CVTTPS2DQ — Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values
- [ ] CVTTPS2PI — Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers
- [ ] CVTTSD2SI — Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Integer
- [ ] CVTTSS2SI — Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer
- [ ] CWD/CDQ/CQO — Convert Word to Doubleword/Convert Doubleword to Quadword
- [ ] DAA — Decimal Adjust AL after Addition
- [ ] DAS — Decimal Adjust AL after Subtraction
- [ ] DEC — Decrement by 1
- [ ] DIV — Unsigned Divide
- [ ] DIVPD — Divide Packed Double-Precision Floating-Point Values
- [ ] DIVPS — Divide Packed Single-Precision Floating-Point Values
- [ ] DIVSD — Divide Scalar Double-Precision Floating-Point Value
- [ ] DIVSS — Divide Scalar Single-Precision Floating-Point Values
- [ ] DPPD — Dot Product of Packed Double Precision Floating-Point Values
- [ ] DPPS — Dot Product of Packed Single Precision Floating-Point Values
- [ ] EMMS — Empty MMX Technology State
- [ ] ENTER — Make Stack Frame for Procedure Parameters
- [ ] EXTRACTPS — Extract Packed Floating-Point Values
- [ ] F2XM1 — Compute 2x–1
- [ ] FABS — Absolute Value
- [ ] FADD/FADDP/FIADD — Add
- [ ] FBLD — Load Binary Coded Decimal
- [ ] FBSTP — Store BCD Integer and Pop
- [ ] FCHS — Change Sign
- [ ] FCLEX/FNCLEX — Clear Exceptions
- [ ] FCMOVcc — Floating-Point Conditional Move
- [ ] FCOM/FCOMP/FCOMPP — Compare Floating Point Values
- [ ] FCOMI/FCOMIP/ FUCOMI/FUCOMIP — Compare Floating Point Values and Set EFLAGS
- [ ] FCOS —  Cosine
- [ ] FDECSTP — Decrement Stack-Top Pointer
- [ ] FDIV/FDIVP/FIDIV — Divide
- [ ] FDIVR/FDIVRP/FIDIVR — Reverse Divide
- [ ] FFREE — Free Floating-Point Register
- [ ] FICOM/FICOMP — Compare Integer
- [ ] FILD — Load Integer
- [ ] FINCSTP — Increment Stack-Top Pointer
- [ ] FINIT/FNINIT — Initialize Floating-Point Unit
- [ ] FIST/FISTP — Store Integer
- [ ] FISTTP — Store Integer with Truncation
- [ ] FLD — Load Floating Point Value
- [ ] FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ — Load Constant
- [ ] FLDCW — Load x87 FPU Control Word
- [ ] FLDENV — Load x87 FPU Environment
- [ ] FMUL/FMULP/FIMUL — Multiply
- [ ] FNOP — No Operation
- [ ] FPATAN — Partial Arctangent
- [ ] FPREM — Partial Remainder
- [ ] FPREM1 — Partial Remainder
- [ ] FPTAN — Partial Tangent
- [ ] FRNDINT — Round to Integer
- [ ] FRSTOR — Restore x87 FPU State
- [ ] FSAVE/FNSAVE — Store x87 FPU State
- [ ] FSCALE — Scale
- [ ] FSIN — Sine
- [ ] FSINCOS — Sine and Cosine
- [ ] FSQRT — Square Root
- [ ] FST/FSTP — Store Floating Point Value
- [ ] FSTCW/FNSTCW — Store x87 FPU Control Word
- [ ] FSTENV/FNSTENV — Store x87 FPU Environment
- [ ] FSTSW/FNSTSW — Store x87 FPU Status Word
- [ ] FSUB/FSUBP/FISUB — Subtract
- [ ] FSUBR/FSUBRP/FISUBR — Reverse Subtract
- [ ] FTST — TEST
- [ ] FUCOM/FUCOMP/FUCOMPP — Unordered Compare Floating Point Values
- [ ] FXAM — Examine Floating-Point
- [ ] FXCH — Exchange Register Contents
- [ ] FXRSTOR — Restore x87 FPU, MMX, XMM, and MXCSR State
- [ ] FXSAVE — Save x87 FPU, MMX Technology, and SSE State
- [ ] FXTRACT — Extract Exponent and Significand
- [ ] FYL2X — Compute y * log2x
- [ ] FYL2XP1 — Compute y * log2(x +1)
- [ ] HADDPD — Packed Double-FP Horizontal Add
- [ ] HADDPS — Packed Single-FP Horizontal Add
- [ ] HLT — Halt
- [ ] HSUBPD — Packed Double-FP Horizontal Subtract
- [ ] HSUBPS — Packed Single-FP Horizontal Subtract
- [ ] IDIV — Signed Divide
- [ ] IMUL — Signed Multiply
- [ ] IN — Input from Port
- [ ] INC — Increment by 1
- [ ] INS/INSB/INSW/INSD — Input from Port to String
- [ ] INSERTPS — Insert Scalar Single-Precision Floating-Point Value
- [ ] INT n/INTO/INT 3 — Call to Interrupt Procedure
- [ ] INVD — Invalidate Internal Caches
- [ ] INVLPG — Invalidate TLB Entries
- [ ] INVPCID — Invalidate Process-Context Identifier
- [ ] IRET/IRETD — Interrupt Return
- [ ] Jcc — Jump if Condition Is Met
- [ ] JMP — Jump
- [ ] KADDW/KADDB/KADDQ/KADDD — ADD Two Masks
- [ ] KANDW/KANDB/KANDQ/KANDD — Bitwise Logical AND Masks
- [ ] KANDNW/KANDNB/KANDNQ/KANDND — Bitwise Logical AND NOT Masks
- [ ] KMOVW/KMOVB/KMOVQ/KMOVD — Move from and to Mask Registers
- [ ] KNOTW/KNOTB/KNOTQ/KNOTD — NOT Mask Register
- [ ] KORW/KORB/KORQ/KORD — Bitwise Logical OR Masks
- [ ] KORTESTW/KORTESTB/KORTESTQ/KORTESTD — OR Masks And Set Flags
- [ ] KSHIFTLW/KSHIFTLB/KSHIFTLQ/KSHIFTLD — Shift Left Mask Registers
- [ ] KSHIFTRW/KSHIFTRB/KSHIFTRQ/KSHIFTRD — Shift Right Mask Registers
- [ ] KTESTW/KTESTB/KTESTQ/KTESTD — Packed Bit Test Masks and Set Flags
- [ ] KUNPCKBW/KUNPCKWD/KUNPCKDQ — Unpack for Mask Registers
- [ ] KXNORW/KXNORB/KXNORQ/KXNORD — Bitwise Logical XNOR Masks
- [ ] KXORW/KXORB/KXORQ/KXORD — Bitwise Logical XOR Masks
- [ ] LAHF — Load Status Flags into AH Register
- [ ] LAR — Load Access Rights Byte
- [ ] LDDQU — Load Unaligned Integer 128 Bits
- [ ] LDMXCSR — Load MXCSR Register
- [ ] LDS/LES/LFS/LGS/LSS — Load Far Pointer
- [x] LEA — Load Effective Address
- [x] LEAVE — High Level Procedure Exit
- [ ] LFENCE — Load Fence
- [ ] LGDT/LIDT — Load Global/Interrupt Descriptor Table Register
- [ ] LLDT — Load Local Descriptor Table Register
- [ ] LMSW — Load Machine Status Word
- [ ] LOCK — Assert LOCK# Signal Prefix
- [ ] LODS/LODSB/LODSW/LODSD/LODSQ — Load String
- [ ] LOOP/LOOPcc — Loop According to ECX Counter
- [ ] LSL — Load Segment Limit
- [ ] LTR — Load Task Register
- [ ] LZCNT —  Count the Number of Leading Zero Bits
- [ ] MASKMOVDQU — Store Selected Bytes of Double Quadword
- [ ] MASKMOVQ — Store Selected Bytes of Quadword
- [ ] MAXPD — Maximum of Packed Double-Precision Floating-Point Values
- [ ] MAXPS — Maximum of Packed Single-Precision Floating-Point Values
- [ ] MAXSD — Return Maximum Scalar Double-Precision Floating-Point Value
- [ ] MAXSS — Return Maximum Scalar Single-Precision Floating-Point Value
- [ ] MFENCE — Memory Fence
- [ ] MINPD — Minimum of Packed Double-Precision Floating-Point Values
- [ ] MINPS — Minimum of Packed Single-Precision Floating-Point Values
- [ ] MINSD — Return Minimum Scalar Double-Precision Floating-Point Value
- [ ] MINSS — Return Minimum Scalar Single-Precision Floating-Point Value
- [ ] MONITOR — Set Up Monitor Address
- [x] MOV — Move
- [ ] MOV — Move to/from Control Registers
- [ ] MOV — Move to/from Debug Registers
- [ ] MOVAPD — Move Aligned Packed Double-Precision Floating-Point Values
- [ ] MOVAPS — Move Aligned Packed Single-Precision Floating-Point Values
- [ ] MOVBE — Move Data After Swapping Bytes
- [ ] MOVD/MOVQ — Move Doubleword/Move Quadword
- [ ] MOVDDUP — Replicate Double FP Values
- [ ] MOVDQA,VMOVDQA32/64 — Move Aligned Packed Integer Values
- [ ] MOVDQU,VMOVDQU8/16/32/64 — Move Unaligned Packed Integer Values
- [ ] MOVDQ2Q — Move Quadword from XMM to MMX Technology Register
- [ ] MOVHLPS — Move Packed Single-Precision Floating-Point Values High to Low
- [ ] MOVHPD — Move High Packed Double-Precision Floating-Point Value
- [ ] MOVHPS — Move High Packed Single-Precision Floating-Point Values
- [ ] MOVLHPS — Move Packed Single-Precision Floating-Point Values Low to High
- [ ] MOVLPD — Move Low Packed Double-Precision Floating-Point Value
- [ ] MOVLPS — Move Low Packed Single-Precision Floating-Point Values
- [ ] MOVMSKPD — Extract Packed Double-Precision Floating-Point Sign Mask
- [ ] MOVMSKPS — Extract Packed Single-Precision Floating-Point Sign Mask
- [ ] MOVNTDQA — Load Double Quadword Non-Temporal Aligned Hint
- [ ] MOVNTDQ — Store Packed Integers Using Non-Temporal Hint
- [ ] MOVNTI — Store Doubleword Using Non-Temporal Hint
- [ ] MOVNTPD — Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint
- [ ] MOVNTPS — Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint
- [ ] MOVNTQ — Store of Quadword Using Non-Temporal Hint
- [ ] MOVQ — Move Quadword
- [ ] MOVQ2DQ — Move Quadword from MMX Technology to XMM Register
- [ ] MOVS/MOVSB/MOVSW/MOVSD/MOVSQ — Move Data from String to String
- [ ] MOVSD — Move or Merge Scalar Double-Precision Floating-Point Value
- [ ] MOVSHDUP — Replicate Single FP Values
- [ ] MOVSLDUP — Replicate Single FP Values
- [ ] MOVSS — Move or Merge Scalar Single-Precision Floating-Point Value
- [ ] MOVSX/MOVSXD — Move with Sign-Extension
- [ ] MOVUPD — Move Unaligned Packed Double-Precision Floating-Point Values
- [ ] MOVUPS — Move Unaligned Packed Single-Precision Floating-Point Values
- [ ] MOVZX — Move with Zero-Extend
- [ ] MPSADBW — Compute Multiple Packed Sums of Absolute Difference
- [ ] MUL — Unsigned Multiply
- [ ] MULPD — Multiply Packed Double-Precision Floating-Point Values
- [ ] MULPS — Multiply Packed Single-Precision Floating-Point Values
- [ ] MULSD — Multiply Scalar Double-Precision Floating-Point Value
- [ ] MULSS — Multiply Scalar Single-Precision Floating-Point Values
- [ ] MULX — Unsigned Multiply Without Affecting Flags
- [ ] MWAIT — Monitor Wait
- [x] NEG — Two's Complement Negation
- [ ] NOP — No Operation
- [x] NOT — One's Complement Negation
- [ ] OR — Logical Inclusive OR
- [ ] ORPD — Bitwise Logical OR of Packed Double Precision Floating-Point Values
- [ ] ORPS — Bitwise Logical OR of Packed Single Precision Floating-Point Values
- [ ] OUT — Output to Port
- [ ] OUTS/OUTSB/OUTSW/OUTSD — Output String to Port
- [ ] PABSB/PABSW/PABSD/PABSQ — Packed Absolute Value
- [ ] PACKSSWB/PACKSSDW — Pack with Signed Saturation
- [ ] PACKUSDW — Pack with Unsigned Saturation
- [ ] PACKUSWB — Pack with Unsigned Saturation
- [ ] PADDB/PADDW/PADDD/PADDQ — Add Packed Integers
- [ ] PADDSB/PADDSW — Add Packed Signed Integers with Signed Saturation
- [ ] PADDUSB/PADDUSW — Add Packed Unsigned Integers with Unsigned Saturation
- [ ] PALIGNR — Packed Align Right
- [ ] PAND — Logical AND
- [ ] PANDN — Logical AND NOT
- [ ] PAUSE — Spin Loop Hint
- [ ] PAVGB/PAVGW — Average Packed Integers
- [ ] PBLENDVB — Variable Blend Packed Bytes
- [ ] PBLENDW — Blend Packed Words
- [ ] PCLMULQDQ - Carry-Less Multiplication Quadword
- [ ] PCMPEQB/PCMPEQW/PCMPEQD —  Compare Packed Data for Equal
- [ ] PCMPEQQ — Compare Packed Qword Data for Equal
- [ ] PCMPESTRI — Packed Compare Explicit Length Strings, Return Index
- [ ] PCMPESTRM — Packed Compare Explicit Length Strings, Return Mask
- [ ] PCMPGTB/PCMPGTW/PCMPGTD — Compare Packed Signed Integers for Greater Than
- [ ] PCMPGTQ — Compare Packed Data for Greater Than
- [ ] PCMPISTRI — Packed Compare Implicit Length Strings, Return Index
- [ ] PCMPISTRM — Packed Compare Implicit Length Strings, Return Mask
- [ ] PDEP — Parallel Bits Deposit
- [ ] PEXT — Parallel Bits Extract
- [ ] PEXTRB/PEXTRD/PEXTRQ — Extract Byte/Dword/Qword
- [ ] PEXTRW — Extract Word
- [ ] PHADDW/PHADDD — Packed Horizontal Add
- [ ] PHADDSW — Packed Horizontal Add and Saturate
- [ ] PHMINPOSUW — Packed Horizontal Word Minimum
- [ ] PHSUBW/PHSUBD — Packed Horizontal Subtract
- [ ] PHSUBSW — Packed Horizontal Subtract and Saturate
- [ ] PINSRB/PINSRD/PINSRQ — Insert Byte/Dword/Qword
- [ ] PINSRW — Insert Word
- [ ] PMADDUBSW — Multiply and Add Packed Signed and Unsigned Bytes
- [ ] PMADDWD — Multiply and Add Packed Integers
- [ ] PMAXSB/PMAXSW/PMAXSD/PMAXSQ — Maximum of Packed Signed Integers
- [ ] PMAXUB/PMAXUW — Maximum of Packed Unsigned Integers
- [ ] PMAXUD/PMAXUQ — Maximum of Packed Unsigned Integers
- [ ] PMINSB/PMINSW — Minimum of Packed Signed Integers
- [ ] PMINSD/PMINSQ — Minimum of Packed Signed Integers
- [ ] PMINUB/PMINUW — Minimum of Packed Unsigned Integers
- [ ] PMINUD/PMINUQ — Minimum of Packed Unsigned Integers
- [ ] PMOVMSKB — Move Byte Mask
- [ ] PMOVSX — Packed Move with Sign Extend
- [ ] PMOVZX — Packed Move with Zero Extend
- [ ] PMULDQ — Multiply Packed Doubleword Integers
- [ ] PMULHRSW — Packed Multiply High with Round and Scale
- [ ] PMULHUW — Multiply Packed Unsigned Integers and Store High Result
- [ ] PMULHW — Multiply Packed Signed Integers and Store High Result
- [ ] PMULLD/PMULLQ — Multiply Packed Integers and Store Low Result
- [ ] PMULLW — Multiply Packed Signed Integers and Store Low Result
- [ ] PMULUDQ — Multiply Packed Unsigned Doubleword Integers
- [x] POP — Pop a Value from the Stack
- [ ] POPA/POPAD — Pop All General-Purpose Registers
- [ ] POPCNT — Return the Count of Number of Bits Set to 1
- [ ] POPF/POPFD/POPFQ — Pop Stack into EFLAGS Register
- [ ] POR — Bitwise Logical OR
- [ ] PREFETCHh — Prefetch Data Into Caches
- [ ] PREFETCHW — Prefetch Data into Caches in Anticipation of a Write
- [ ] PREFETCHWT1 — Prefetch Vector Data Into Caches with Intent to Write and T1 Hint
- [ ] PSADBW — Compute Sum of Absolute Differences
- [ ] PSHUFB — Packed Shuffle Bytes
- [ ] PSHUFD — Shuffle Packed Doublewords
- [ ] PSHUFHW — Shuffle Packed High Words
- [ ] PSHUFLW — Shuffle Packed Low Words
- [ ] PSHUFW — Shuffle Packed Words
- [ ] PSIGNB/PSIGNW/PSIGND — Packed SIGN
- [ ] PSLLDQ — Shift Double Quadword Left Logical
- [ ] PSLLW/PSLLD/PSLLQ — Shift Packed Data Left Logical
- [ ] PSRAW/PSRAD/PSRAQ — Shift Packed Data Right Arithmetic
- [ ] PSRLDQ — Shift Double Quadword Right Logical
- [ ] PSRLW/PSRLD/PSRLQ — Shift Packed Data Right Logical
- [ ] PSUBB/PSUBW/PSUBD — Subtract Packed Integers
- [ ] PSUBQ — Subtract Packed Quadword Integers
- [ ] PSUBSB/PSUBSW — Subtract Packed Signed Integers with Signed Saturation
- [ ] PSUBUSB/PSUBUSW — Subtract Packed Unsigned Integers with Unsigned Saturation
- [ ] PTEST- Logical Compare
- [ ] PTWRITE - Write Data to a Processor Trace Packet
- [ ] PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ —  Unpack High Data
- [ ] PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ — Unpack Low Data
- [x] PUSH — Push Word, Doubleword or Quadword Onto the Stack
- [ ] PUSHA/PUSHAD — Push All General-Purpose Registers
- [ ] PUSHF/PUSHFD — Push EFLAGS Register onto the Stack
- [ ] PXOR — Logical Exclusive OR
- [ ] RCL/RCR/ROL/ROR — Rotate
- [ ] RCPPS — Compute Reciprocals of Packed Single-Precision Floating-Point Values
- [ ] RCPSS — Compute Reciprocal of Scalar Single-Precision Floating-Point Values
- [ ] RDFSBASE/RDGSBASE — Read FS/GS Segment Base
- [ ] RDMSR — Read from Model Specific Register
- [ ] RDPID — Read Processor ID
- [ ] RDPKRU — Read Protection Key Rights for User Pages
- [ ] RDPMC — Read Performance-Monitoring Counters
- [ ] RDRAND — Read Random Number
- [ ] RDSEED — Read Random SEED
- [ ] RDTSC — Read Time-Stamp Counter
- [ ] RDTSCP — Read Time-Stamp Counter and Processor ID
- [ ] REP/REPE/REPZ/REPNE/REPNZ — Repeat String Operation Prefix
- [x] RET — Return from Procedure
- [ ] RORX — Rotate Right Logical Without Affecting Flags
- [ ] ROUNDPD — Round Packed Double Precision Floating-Point Values
- [ ] ROUNDPS — Round Packed Single Precision Floating-Point Values
- [ ] ROUNDSD — Round Scalar Double Precision Floating-Point Values
- [ ] ROUNDSS — Round Scalar Single Precision Floating-Point Values
- [ ] RSM — Resume from System Management Mode
- [ ] RSQRTPS — Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values
- [ ] RSQRTSS — Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value
- [ ] SAHF — Store AH into Flags
- [ ] SAL/SAR/SHL/SHR — Shift
- [ ] SARX/SHLX/SHRX — Shift Without Affecting Flags
- [ ] SBB — Integer Subtraction with Borrow
- [ ] SCAS/SCASB/SCASW/SCASD — Scan String
- [ ] SETcc — Set Byte on Condition
- [ ] SFENCE — Store Fence
- [ ] SGDT — Store Global Descriptor Table Register
- [ ] SHA1RNDS4 — Perform Four Rounds of SHA1 Operation
- [ ] SHA1NEXTE — Calculate SHA1 State Variable E after Four Rounds
- [ ] SHA1MSG1 — Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords
- [ ] SHA1MSG2 — Perform a Final Calculation for the Next Four SHA1 Message Dwords
- [ ] SHA256RNDS2 — Perform Two Rounds of SHA256 Operation
- [ ] SHA256MSG1 — Perform an Intermediate Calculation for the Next Four SHA256 Message Dwords
- [ ] SHA256MSG2 — Perform a Final Calculation for the Next Four SHA256 Message Dwords
- [ ] SHLD — Double Precision Shift Left
- [ ] SHRD — Double Precision Shift Right
- [ ] SHUFPD — Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values
- [ ] SHUFPS — Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values
- [ ] SIDT — Store Interrupt Descriptor Table Register
- [ ] SLDT — Store Local Descriptor Table Register
- [ ] SMSW — Store Machine Status Word
- [ ] SQRTPD — Square Root of Double-Precision Floating-Point Values
- [ ] SQRTPS — Square Root of Single-Precision Floating-Point Values
- [ ] SQRTSD — Compute Square Root of Scalar Double-Precision Floating-Point Value
- [ ] SQRTSS — Compute Square Root of Scalar Single-Precision Value
- [ ] STAC — Set AC Flag in EFLAGS Register
- [ ] STC — Set Carry Flag
- [ ] STD — Set Direction Flag
- [ ] STI — Set Interrupt Flag
- [ ] STMXCSR — Store MXCSR Register State
- [ ] STOS/STOSB/STOSW/STOSD/STOSQ — Store String
- [ ] STR — Store Task Register
- [x] SUB — Subtract
- [ ] SUBPD — Subtract Packed Double-Precision Floating-Point Values
- [ ] SUBPS — Subtract Packed Single-Precision Floating-Point Values
- [ ] SUBSD — Subtract Scalar Double-Precision Floating-Point Value
- [ ] SUBSS — Subtract Scalar Single-Precision Floating-Point Value
- [ ] SWAPGS — Swap GS Base Register
- [x] SYSCALL — Fast System Call
- [ ] SYSENTER — Fast System Call
- [ ] SYSEXIT — Fast Return from Fast System Call
- [ ] SYSRET — Return From Fast System Call
- [ ] TEST — Logical Compare
- [ ] TZCNT — Count the Number of Trailing Zero Bits
- [ ] UCOMISD — Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS
- [ ] UCOMISS — Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS
- [ ] UD2 — Undefined Instruction
- [ ] UNPCKHPD — Unpack and Interleave High Packed Double-Precision Floating-Point Values
- [ ] UNPCKHPS — Unpack and Interleave High Packed Single-Precision Floating-Point Values
- [ ] UNPCKLPD — Unpack and Interleave Low Packed Double-Precision Floating-Point Values
- [ ] UNPCKLPS — Unpack and Interleave Low Packed Single-Precision Floating-Point Values
- [ ] VALIGND/VALIGNQ — Align Doubleword/Quadword Vectors
- [ ] VBLENDMPD/VBLENDMPS — Blend Float64/Float32 Vectors Using an OpMask Control
- [ ] VBROADCAST — Load with Broadcast Floating-Point Data
- [ ] VPBROADCASTM — Broadcast Mask to Vector Register
- [ ] VCOMPRESSPD — Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory
- [ ] VCOMPRESSPS — Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory
- [ ] VCVTPD2QQ — Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers
- [ ] VCVTPD2UDQ — Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers
- [ ] VCVTPD2UQQ — Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers
- [ ] VCVTPH2PS — Convert 16-bit FP values to Single-Precision FP values
- [ ] VCVTPS2PH — Convert Single-Precision FP value to 16-bit FP value
- [ ] VCVTPS2UDQ — Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values
- [ ] VCVTPS2QQ — Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values
- [ ] VCVTPS2UQQ — Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values
- [ ] VCVTQQ2PD — Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values
- [ ] VCVTQQ2PS — Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values
- [ ] VCVTSD2USI — Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer
- [ ] VCVTSS2USI — Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer
- [ ] VCVTTPD2QQ — Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers
- [ ] VCVTTPD2UDQ — Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers
- [ ] VCVTTPD2UQQ — Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers
- [ ] VCVTTPS2UDQ — Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values
- [ ] VCVTTPS2QQ — Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values
- [ ] VCVTTPS2UQQ — Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values
- [ ] VCVTTSD2USI — Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer
- [ ] VCVTTSS2USI — Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer
- [ ] VCVTUDQ2PD — Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values
- [ ] VCVTUDQ2PS — Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values
- [ ] VCVTUQQ2PD — Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values
- [ ] VCVTUQQ2PS — Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values
- [ ] VCVTUSI2SD — Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value
- [ ] VCVTUSI2SS — Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value
- [ ] VDBPSADBW — Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes
- [ ] VEXPANDPD — Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory
- [ ] VEXPANDPS — Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory
- [ ] VERR/VERW — Verify a Segment for Reading or Writing
- [ ] VEXP2PD — Approximation to the Exponential 2^x of Packed Double-Precision Floating-Point Values with Less Than 2^-23 Relative Error
- [ ] VEXP2PS — Approximation to the Exponential 2^x of Packed Single-Precision Floating-Point Values with Less Than 2^-23 Relative Error
- [ ] VEXTRACTF128/VEXTRACTF32x4/VEXTRACTF64x2/VEXTRACTF32x8/VEXTRACTF64x4 — Extract Packed Floating-Point Values
- [ ] VEXTRACTI128/VEXTRACTI32x4/VEXTRACTI64x2/VEXTRACTI32x8/VEXTRACTI64x4 — Extract packed Integer Values
- [ ] VFIXUPIMMPD — Fix Up Special Packed Float64 Values
- [ ] VFIXUPIMMPS — Fix Up Special Packed Float32 Values
- [ ] VFIXUPIMMSD — Fix Up Special Scalar Float64 Value
- [ ] VFIXUPIMMSS — Fix Up Special Scalar Float32 Value
- [ ] VFMADD132PD/VFMADD213PD/VFMADD231PD — Fused Multiply-Add of Packed Double-Precision Floating-Point Values
- [ ] VFMADD132PS/VFMADD213PS/VFMADD231PS — Fused Multiply-Add of Packed Single-Precision Floating-Point Values
- [ ] VFMADD132SD/VFMADD213SD/VFMADD231SD — Fused Multiply-Add of Scalar Double-Precision Floating-Point Values
- [ ] VFMADD132SS/VFMADD213SS/VFMADD231SS — Fused Multiply-Add of Scalar Single-Precision Floating-Point Values
- [ ] VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD — Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values
- [ ] VFMADDSUB132PS/VFMADDSUB213PS/VFMADDSUB231PS — Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values
- [ ] VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD — Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values
- [ ] VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS — Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values
- [ ] VFMSUB132PD/VFMSUB213PD/VFMSUB231PD — Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values
- [ ] VFMSUB132PS/VFMSUB213PS/VFMSUB231PS — Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values
- [ ] VFMSUB132SD/VFMSUB213SD/VFMSUB231SD — Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values
- [ ] VFMSUB132SS/VFMSUB213SS/VFMSUB231SS — Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values
- [ ] VFNMADD132PD/VFNMADD213PD/VFNMADD231PD — Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values
- [ ] VFNMADD132PS/VFNMADD213PS/VFNMADD231PS — Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values
- [ ] VFNMADD132SD/VFNMADD213SD/VFNMADD231SD — Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values
- [ ] VFNMADD132SS/VFNMADD213SS/VFNMADD231SS — Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values
- [ ] VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD — Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values
- [ ] VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS — Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values
- [ ] VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD — Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values
- [ ] VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS — Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values
- [ ] VFPCLASSPD — Tests Types Of a Packed Float64 Values
- [ ] VFPCLASSPS — Tests Types Of a Packed Float32 Values
- [ ] VFPCLASSSD — Tests Types Of a Scalar Float64 Values
- [ ] VFPCLASSSS — Tests Types Of a Scalar Float32 Values
- [ ] VGATHERDPD/VGATHERQPD — Gather Packed DP FP Values Using Signed Dword/Qword Indices
- [ ] VGATHERDPS/VGATHERQPS — Gather Packed SP FP values Using Signed Dword/Qword Indices
- [ ] VGATHERDPS/VGATHERDPD — Gather Packed Single, Packed Double with Signed Dword
- [ ] VGATHERPF0DPS/VGATHERPF0QPS/VGATHERPF0DPD/VGATHERPF0QPD — Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint
- [ ] VGATHERPF1DPS/VGATHERPF1QPS/VGATHERPF1DPD/VGATHERPF1QPD — Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint
- [ ] VGATHERQPS/VGATHERQPD — Gather Packed Single, Packed Double with Signed Qword Indices
- [ ] VPGATHERDD/VPGATHERQD — Gather Packed Dword Values Using Signed Dword/Qword Indices
- [ ] VPGATHERDD/VPGATHERDQ — Gather Packed Dword, Packed Qword with Signed Dword Indices
- [ ] VPGATHERDQ/VPGATHERQQ — Gather Packed Qword Values Using Signed Dword/Qword Indices
- [ ] VPGATHERQD/VPGATHERQQ — Gather Packed Dword, Packed Qword with Signed Qword Indices
- [ ] VGETEXPPD — Convert Exponents of Packed DP FP Values to DP FP Values
- [ ] VGETEXPPS — Convert Exponents of Packed SP FP Values to SP FP Values
- [ ] VGETEXPSD — Convert Exponents of Scalar DP FP Values to DP FP Value
- [ ] VGETEXPSS — Convert Exponents of Scalar SP FP Values to SP FP Value
- [ ] VGETMANTPD — Extract Float64 Vector of Normalized Mantissas from Float64 Vector
- [ ] VGETMANTPS — Extract Float32 Vector of Normalized Mantissas from Float32 Vector
- [ ] VGETMANTSD — Extract Float64 of Normalized Mantissas from Float64 Scalar
- [ ] VGETMANTSS — Extract Float32 Vector of Normalized Mantissa from Float32 Vector
- [ ] VINSERTF128/VINSERTF32x4/VINSERTF64x2/VINSERTF32x8/VINSERTF64x4 — Insert Packed Floating-Point Values
- [ ] VINSERTI128/VINSERTI32x4/VINSERTI64x2/VINSERTI32x8/VINSERTI64x4 — Insert Packed Integer Values
- [ ] VMASKMOV — Conditional SIMD Packed Loads and Stores
- [ ] VPBLENDD — Blend Packed Dwords
- [ ] VPBLENDMB/VPBLENDMW — Blend Byte/Word Vectors Using an Opmask Control
- [ ] VPBLENDMD/VPBLENDMQ — Blend Int32/Int64 Vectors Using an OpMask Control
- [ ] VPBROADCASTB/W/D/Q — Load with Broadcast Integer Data from General Purpose Register
- [ ] VPBROADCAST — Load Integer and Broadcast
- [ ] VPCMPB/VPCMPUB — Compare Packed Byte Values Into Mask
- [ ] VPCMPD/VPCMPUD — Compare Packed Integer Values into Mask
- [ ] VPCMPQ/VPCMPUQ — Compare Packed Integer Values into Mask
- [ ] VPCMPW/VPCMPUW — Compare Packed Word Values Into Mask
- [ ] VPCOMPRESSD — Store Sparse Packed Doubleword Integer Values into Dense Memory/Register
- [ ] VPCOMPRESSQ — Store Sparse Packed Quadword Integer Values into Dense Memory/Register
- [ ] VPCONFLICTD/Q — Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register
- [ ] VPERM2F128 — Permute Floating-Point Values
- [ ] VPERM2I128 — Permute Integer Values
- [ ] VPERMD/VPERMW — Permute Packed Doublewords/Words Elements
- [ ] VPERMI2W/D/Q/PS/PD — Full Permute From Two Tables Overwriting the Index
- [ ] VPERMILPD — Permute In-Lane of Pairs of Double-Precision Floating-Point Values
- [ ] VPERMILPS — Permute In-Lane of Quadruples of Single-Precision Floating-Point Values
- [ ] VPERMPD — Permute Double-Precision Floating-Point Elements
- [ ] VPERMPS — Permute Single-Precision Floating-Point Elements
- [ ] VPERMQ — Qwords Element Permutation
- [ ] VPEXPANDD — Load Sparse Packed Doubleword Integer Values from Dense Memory / Register
- [ ] VPEXPANDQ — Load Sparse Packed Quadword Integer Values from Dense Memory / Register
- [ ] VPLZCNTD/Q — Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values
- [ ] VPMASKMOV — Conditional SIMD Integer Packed Loads and Stores
- [ ] VPMOVM2B/VPMOVM2W/VPMOVM2D/VPMOVM2Q — Convert a Mask Register to a Vector Register
- [ ] VPMOVB2M/VPMOVW2M/VPMOVD2M/VPMOVQ2M — Convert a Vector Register to a Mask
- [ ] VPMOVQB/VPMOVSQB/VPMOVUSQB — Down Convert QWord to Byte
- [ ] VPMOVQW/VPMOVSQW/VPMOVUSQW — Down Convert QWord to Word
- [ ] VPMOVQD/VPMOVSQD/VPMOVUSQD — Down Convert QWord to DWord
- [ ] VPMOVDB/VPMOVSDB/VPMOVUSDB — Down Convert DWord to Byte
- [ ] VPMOVDW/VPMOVSDW/VPMOVUSDW — Down Convert DWord to Word
- [ ] VPMOVWB/VPMOVSWB/VPMOVUSWB — Down Convert Word to Byte
- [ ] PROLD/PROLVD/PROLQ/PROLVQ — Bit Rotate Left
- [ ] PRORD/PRORVD/PRORQ/PRORVQ — Bit Rotate  Right
- [ ] VPSCATTERDD/VPSCATTERDQ/VPSCATTERQD/VPSCATTERQQ — Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices
- [ ] VPSLLVW/VPSLLVD/VPSLLVQ — Variable Bit Shift Left Logical
- [ ] VPSRAVW/VPSRAVD/VPSRAVQ — Variable Bit Shift Right Arithmetic
- [ ] VPSRLVW/VPSRLVD/VPSRLVQ — Variable Bit Shift Right Logical
- [ ] VPTERNLOGD/VPTERNLOGQ — Bitwise Ternary Logic
- [ ] VPTESTMB/VPTESTMW/VPTESTMD/VPTESTMQ — Logical AND and Set Mask
- [ ] VPTESTNMB/W/D/Q — Logical NAND and Set
- [ ] VRANGEPD — Range Restriction Calculation For Packed Pairs of Float64 Values
- [ ] VRANGEPS — Range Restriction Calculation For Packed Pairs of Float32 Values
- [ ] VRANGESD — Range Restriction Calculation From a pair of Scalar Float64 Values
- [ ] VRANGESS — Range Restriction Calculation From a Pair of Scalar Float32 Values
- [ ] VRCP14PD — Compute Approximate Reciprocals of Packed Float64 Values
- [ ] VRCP14SD — Compute Approximate Reciprocal of Scalar Float64 Value
- [ ] VRCP14PS — Compute Approximate Reciprocals of Packed Float32 Values
- [ ] VRCP14SS — Compute Approximate Reciprocal of Scalar Float32 Value
- [ ] VRCP28PD — Approximation to the Reciprocal of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error
- [ ] VRCP28SD — Approximation to the Reciprocal of Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error
- [ ] VRCP28PS — Approximation to the Reciprocal of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error
- [ ] VRCP28SS — Approximation to the Reciprocal of Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error
- [ ] VREDUCEPD — Perform Reduction Transformation on Packed Float64 Values
- [ ] VREDUCESD — Perform a Reduction Transformation on a Scalar Float64 Value
- [ ] VREDUCEPS — Perform Reduction Transformation on Packed Float32 Values
- [ ] VREDUCESS — Perform a Reduction Transformation on a Scalar Float32 Value
- [ ] VRNDSCALEPD — Round Packed Float64 Values To Include A Given Number Of Fraction Bits
- [ ] VRNDSCALESD — Round Scalar Float64 Value To Include A Given Number Of Fraction Bits
- [ ] VRNDSCALEPS — Round Packed Float32 Values To Include A Given Number Of Fraction Bits
- [ ] VRNDSCALESS — Round Scalar Float32 Value To Include A Given Number Of Fraction Bits
- [ ] VRSQRT14PD — Compute Approximate Reciprocals of Square Roots of Packed Float64 Values
- [ ] VRSQRT14SD — Compute Approximate Reciprocal of Square Root of Scalar Float64 Value
- [ ] VRSQRT14PS — Compute Approximate Reciprocals of Square Roots of Packed Float32 Values
- [ ] VRSQRT14SS — Compute Approximate Reciprocal of Square Root of Scalar Float32 Value
- [ ] VRSQRT28PD — Approximation to the Reciprocal Square Root of Packed Double-Precision Floating-Point Values with Less Than 2^-28 Relative Error
- [ ] VRSQRT28SD — Approximation to the Reciprocal Square Root of Scalar Double-Precision Floating-Point Value with Less Than 2^-28 Relative Error
- [ ] VRSQRT28PS — Approximation to the Reciprocal Square Root of Packed Single-Precision Floating-Point Values with Less Than 2^-28 Relative Error
- [ ] VRSQRT28SS — Approximation to the Reciprocal Square Root of Scalar Single-Precision Floating-Point Value with Less Than 2^-28 Relative Error
- [ ] VSCALEFPD — Scale Packed Float64 Values With Float64 Values
- [ ] VSCALEFSD — Scale Scalar Float64 Values With Float64 Values
- [ ] VSCALEFPS — Scale Packed Float32 Values With Float32 Values
- [ ] VSCALEFSS — Scale Scalar Float32 Value With Float32 Value
- [ ] VSCATTERDPS/VSCATTERDPD/VSCATTERQPS/VSCATTERQPD — Scatter Packed Single, Packed Double with Signed Dword and Qword Indices
- [ ] VSCATTERPF0DPS/VSCATTERPF0QPS/VSCATTERPF0DPD/VSCATTERPF0QPD — Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T0 Hint with Intent to Write
- [ ] VSCATTERPF1DPS/VSCATTERPF1QPS/VSCATTERPF1DPD/VSCATTERPF1QPD — Sparse Prefetch Packed SP/DP Data Values with Signed Dword, Signed Qword Indices Using T1 Hint with Intent to Write
- [ ] VSHUFF32x4/VSHUFF64x2/VSHUFI32x4/VSHUFI64x2 — Shuffle Packed Values at 128-bit Granularity
- [ ] VTESTPD/VTESTPS — Packed Bit Test
- [ ] VZEROALL — Zero All YMM Registers
- [ ] VZEROUPPER — Zero Upper Bits of YMM Registers
- [ ] WAIT/FWAIT — Wait
- [ ] WBINVD — Write Back and Invalidate Cache
- [ ] WRFSBASE/WRGSBASE — Write FS/GS Segment Base
- [ ] WRMSR — Write to Model Specific Register
- [ ] WRPKRU — Write Data to User Page Key Register
- [ ] XACQUIRE/XRELEASE — Hardware Lock Elision Prefix Hints
- [ ] XABORT — Transactional Abort
- [ ] XADD — Exchange and Add
- [ ] XBEGIN — Transactional Begin
- [ ] XCHG — Exchange Register/Memory with Register
- [ ] XEND — Transactional End
- [ ] XGETBV — Get Value of Extended Control Register
- [ ] XLAT/XLATB — Table Look-up Translation
- [x] XOR — Logical Exclusive OR
- [ ] XORPD — Bitwise Logical XOR of Packed Double Precision Floating-Point Values
- [ ] XORPS — Bitwise Logical XOR of Packed Single Precision Floating-Point Values
- [ ] XRSTOR — Restore Processor Extended States
- [ ] XRSTORS — Restore Processor Extended States Supervisor
- [ ] XSAVE — Save Processor Extended States
- [ ] XSAVEC — Save Processor Extended States with Compaction
- [ ] XSAVEOPT — Save Processor Extended States Optimized
- [ ] XSAVES — Save Processor Extended States Supervisor
- [ ] XSETBV — Set Extended Control Register
